{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Documentation","text":"<p>Clarity comes from simple explanation, not elite articulation.</p>"},{"location":"devops/","title":"DevOps","text":"<p>This section contains my DevOps notes and learning path.</p>"},{"location":"devops/introduction/why-devops/","title":"Why DevOps?","text":"","tags":["devops"]},{"location":"devops/introduction/why-devops/#a-simple-starting-point","title":"A simple starting point","text":"<p>A developer writes some code.</p> <p>The code works on the developer\u2019s laptop. Now it needs to run on a server so users can use it.</p> <p>This step moving code from a laptop to a server is where problems usually start.</p>","tags":["devops"]},{"location":"devops/introduction/why-devops/#what-was-the-problem","title":"What was the problem?","text":"<p>Earlier, deployments followed a documented checklist.</p> <p>A typical checklist looked like this:</p> <ol> <li>Download the build  </li> <li>Unzip it  </li> <li>Copy files to the application directory  </li> <li>Ensure correct file ownership and permissions  </li> <li>Restart the application  </li> </ol> <p>The issue was not lack of documentation.</p> <p>The issue was how the same steps were executed.</p>","tags":["devops"]},{"location":"devops/introduction/why-devops/#a-realistic-example-of-variation","title":"A realistic example of variation","text":"<p>Consider this checklist step:</p> <p>\u201cEnsure correct file ownership and permissions\u201d</p> <p>The document also stated: - Files should be owned by <code>appuser</code> - Permissions should match the existing release</p> <p>Now two engineers follow this.</p>","tags":["devops"]},{"location":"devops/introduction/why-devops/#engineer-a","title":"Engineer A","text":"<ul> <li>Copies the new files over the existing directory</li> <li>Old files that no longer exist in the new build are left behind</li> <li>Existing ownership and permissions are preserved</li> </ul>","tags":["devops"]},{"location":"devops/introduction/why-devops/#engineer-b","title":"Engineer B","text":"<ul> <li>Removes the old directory completely</li> <li>Copies the new files into a clean directory</li> <li>Applies ownership and permissions explicitly</li> </ul> <p>Both approaches are reasonable. Both follow the document.</p> <p>But the result is different.</p>","tags":["devops"]},{"location":"devops/introduction/why-devops/#why-was-this-risky","title":"Why was this risky?","text":"<p>Because copying over an old directory can:</p> <ul> <li>Leave obsolete files on disk  </li> <li>Preserve permissions from a previous release  </li> <li>Apply unintended configuration  </li> <li>Make behavior depend on what was deployed earlier  </li> </ul> <p>The application may start successfully and still behave incorrectly later.</p>","tags":["devops"]},{"location":"devops/introduction/why-devops/#the-simple-idea-behind-devops","title":"The simple idea behind DevOps","text":"<p>A small but important change:</p> <p>\u201cEvery deployment must create the same directory structure, with the same files, ownership, and permissions \u2014 regardless of what existed before.\u201d</p> <p>So instead of: - Adjusting things based on the previous deployment</p> <p>We move to: - Recreating the application directory in a known way - Applying ownership and permissions explicitly - Making each deployment independent of history</p> <p>This approach is called DevOps.</p>","tags":["devops"]},{"location":"devops/introduction/why-devops/#what-changed-after-this","title":"What changed after this?","text":"<ul> <li>Deployments behaved the same way every time  </li> <li>Permission issues stopped appearing unexpectedly  </li> <li>Old files stopped affecting new releases  </li> <li>Failures became easier to explain and reproduce  </li> </ul> <p>Nothing became fancy. Things became predictable.</p>","tags":["devops"]},{"location":"devops/introduction/why-devops/#one-takeaway","title":"One takeaway","text":"<p>DevOps exists because relying on previous server state is risky.</p> <p>DevOps removes that risk by recreating the application exactly as intended on every deployment.</p>","tags":["devops"]},{"location":"devops/linux/linux-commands/","title":"Introduction to Linux (How to Think)","text":"<p>This document introduces Linux by explaining how to reason about a Linux system, not just which commands exist. The goal is to help understand why Linux behaves the way it does, so later topics (DevOps, containers, automation) feel natural.</p>","tags":["devops"]},{"location":"devops/linux/linux-commands/#how-linux-is-different-from-windows-the-core-idea","title":"How Linux is different from Windows (the core idea)","text":"<p>Linux and Windows solve different problems.</p> <p>Windows was designed for individual desktop users:</p> <ul> <li>Strong focus on GUI</li> <li>System internals are intentionally hidden</li> <li>Manual interaction is the default</li> </ul> <p>Linux was designed for multi-user systems and servers:</p> <ul> <li>System internals are visible</li> <li>Everything is controlled using files and processes</li> <li>Automation is expected, not optional</li> </ul> <p>A useful mental model:</p> <ul> <li>Windows is like ready-made furniture: polished and convenient, but hard to modify internally.</li> <li>Linux is like Lego bricks in a workshop: smaller pieces, fully visible, and easy to assemble differently.</li> </ul> <p>This single difference explains why Linux dominates servers and DevOps.</p>","tags":["devops"]},{"location":"devops/linux/linux-commands/#why-linux-became-the-base-for-devops-and-cloud","title":"Why Linux became the base for DevOps and cloud","text":"<p>Linux exposes low-level system behavior in a way automation tools can directly control.</p>","tags":["devops"]},{"location":"devops/linux/linux-commands/#containers-why-linux-is-required","title":"Containers (why Linux is required)","text":"<p>Containers are not a generic technology; they depend on Linux kernel features:</p> <ul> <li>Namespaces isolate processes, networks, and filesystems.</li> <li>cgroups control CPU and memory usage.</li> <li>chroot limits filesystem visibility.</li> </ul> <p>Because of this:</p> <ul> <li>A container is a restricted Linux process.</li> <li>It is not a virtual machine.</li> <li>On Windows or macOS, Docker runs a small Linux VM in the background.</li> <li>Containers still execute on a Linux kernel.</li> </ul> <p>This is a technical dependency, not a preference.</p>","tags":["devops"]},{"location":"devops/linux/linux-commands/#configuration-management-ansible","title":"Configuration management (Ansible)","text":"<p>Ansible assumes Linux-style systems:</p> <ul> <li>SSH-based remote execution</li> <li>Text configuration files</li> <li>Linux users, permissions, and package managers</li> </ul> <p>Windows support exists, but:</p> <ul> <li>Requires WinRM</li> <li>Uses separate modules</li> <li>Adds complexity</li> </ul> <p>Linux aligns naturally with automation, so it remains the default.</p>","tags":["devops"]},{"location":"devops/linux/linux-commands/#what-linux-actually-means-distributions","title":"What \u201cLinux\u201d actually means (distributions)","text":"<p>Linux itself is only the kernel. A usable system is created by combining the kernel with tools, libraries, and defaults. This is called a distribution.</p> <p>Example:</p> <ul> <li>RHEL = enterprise Linux with paid support</li> <li>CentOS = community rebuild of RHEL (same structure, no support)</li> </ul> <p>Different distributions exist, but the core concepts do not change.</p>","tags":["devops"]},{"location":"devops/linux/linux-commands/#how-you-interact-with-linux-cli-first-thinking","title":"How you interact with Linux (CLI-first thinking)","text":"<p>Linux provides both GUI and CLI, but servers are CLI-only.</p> <p>This matters because:</p> <ul> <li>Scripts run CLI commands</li> <li>Automation uses CLI commands</li> <li>Troubleshooting happens via CLI</li> </ul> <p>Learning Linux means learning to reason through commands, not click through menus.</p>","tags":["devops"]},{"location":"devops/linux/linux-commands/#shells-how-linux-interprets-commands","title":"Shells: how Linux interprets commands","text":"<p>A shell is the program that reads your command and decides what to execute.</p> <p>Common shells:</p> <ul> <li><code>sh</code> \u2013 original Bourne shell</li> <li><code>csh</code> / <code>tcsh</code> \u2013 C-style syntax</li> <li><code>zsh</code> \u2013 modern interactive shell</li> <li><code>bash</code> \u2013 default on most enterprise systems</li> </ul> <p><code>bash</code> is important because it supports:</p> <ul> <li>Variables</li> <li>Arithmetic</li> <li>Conditions</li> <li>Loops</li> <li>Scripts</li> </ul> <p>Check which shell you are using:</p> <pre><code>echo $SHELL\n</code></pre> <p>Interpretation:</p> <ul> <li><code>/bin/bash</code> means Bash is processing your commands</li> <li>Scripts will behave according to Bash rules</li> </ul>","tags":["devops"]},{"location":"devops/linux/linux-commands/#understanding-the-operating-system-thinking-not-guessing","title":"Understanding the operating system (thinking, not guessing)","text":"<p>Before running commands or installing software, you must know what OS you are on. Different OS versions mean different package managers, paths, and defaults.</p>","tags":["devops"]},{"location":"devops/linux/linux-commands/#method-1-distribution-identity-most-common","title":"Method 1: Distribution identity (most common)","text":"<pre><code>cat /etc/os-release\n</code></pre> <p>This tells you:</p> <ul> <li>Distribution name</li> <li>Version</li> <li>Vendor</li> </ul> <p>Use this when deciding:</p> <ul> <li>Which package manager to use</li> <li>Which documentation applies</li> </ul>","tags":["devops"]},{"location":"devops/linux/linux-commands/#method-2-compatibility-check-practical-admin-view","title":"Method 2: Compatibility check (practical admin view)","text":"<pre><code>ls /etc/*release*\n</code></pre> <p>Why this exists:</p> <ul> <li>Many tools and scripts only check for file presence</li> <li>Legacy systems may not have <code>os-release</code></li> </ul> <p>This helps you reason about backward compatibility.</p>","tags":["devops"]},{"location":"devops/linux/linux-commands/#method-3-kernel-vs-os-distinction-advanced-thinking","title":"Method 3: Kernel vs OS distinction (advanced thinking)","text":"<pre><code>uname -a\n</code></pre> <p>This tells you:</p> <ul> <li>Kernel version</li> <li>Architecture</li> </ul> <p>Important insight:</p> <ul> <li>Two systems can run the same kernel</li> <li>But behave differently due to distribution-level tools</li> </ul> <p>Kernel \u2260 distribution.</p>","tags":["devops"]},{"location":"devops/linux/linux-commands/#core-linux-commands-mental-model-first","title":"Core Linux commands (mental model first)","text":"<p>Linux commands are intentionally small and focused.</p> <p>Examples:</p> <pre><code>echo Hi        # print output\nls             # list files\ncd /path       # move in filesystem\npwd            # show current location\nmkdir test     # create directory\n</code></pre> <p>Key idea:</p> <ul> <li>Commands do one thing</li> <li>You combine them to do complex tasks</li> </ul>","tags":["devops"]},{"location":"devops/linux/linux-commands/#files-and-directories","title":"Files and directories","text":"<p>Create nested paths:</p> <pre><code>mkdir -p /tmp/asia/india/bangalore\n</code></pre> <p>Remove recursively:</p> <pre><code>rm -r old_dir\n</code></pre> <p>Copy directories:</p> <pre><code>cp -r src dest\n</code></pre> <p>Create files:</p> <pre><code>touch file.txt\n</code></pre> <p>Write content:</p> <pre><code>cat &gt; file.txt\n</code></pre> <p>Read content:</p> <pre><code>cat file.txt\n</code></pre> <p>Linux treats everything as files, including configuration and devices.</p>","tags":["devops"]},{"location":"devops/linux/linux-commands/#editing-files-with-vi-why-it-still-exists","title":"Editing files with vi (why it still exists)","text":"<p><code>vi</code> is always available, even on minimal servers.</p> <p>Understanding vi is about survivability, not preference.</p> <p>Basic flow:</p> <ul> <li>Open file \u2192 command mode</li> <li>Press <code>i</code> \u2192 insert mode</li> <li>Press <code>Esc</code> \u2192 command mode</li> </ul> <p>Common actions:</p> <ul> <li>Save: <code>:w</code></li> <li>Quit: <code>:q</code></li> <li>Save and quit: <code>:wq</code></li> <li>Search: <code>/word</code></li> </ul> <p>You do not need speed. You need reliability.</p>","tags":["devops"]},{"location":"devops/linux/linux-commands/#users-and-permissions-how-linux-thinks-about-access","title":"Users and permissions (how Linux thinks about access)","text":"<p>Linux separates identity from privilege.</p> <p>Check identity:</p> <pre><code>whoami\nid\n</code></pre> <p>Switch users:</p> <pre><code>su\n</code></pre> <p>Remote login:</p> <pre><code>ssh user@host\n</code></pre> <p><code>root</code> is the superuser. Regular users are restricted by default.</p> <p>Example:</p> <pre><code>ls /root\n</code></pre> <p>Result:</p> <pre><code>Permission denied\n</code></pre> <p>With controlled privilege:</p> <pre><code>sudo ls /root\n</code></pre> <p>Sudo:</p> <ul> <li>Temporarily elevates privilege</li> <li>Requires user authentication</li> <li>Logs every action</li> </ul>","tags":["devops"]},{"location":"devops/linux/linux-commands/#downloading-files-automation-friendly","title":"Downloading files (automation-friendly)","text":"<p>Using curl:</p> <pre><code>curl &lt;url&gt; -O\n</code></pre> <p>Using wget:</p> <pre><code>wget &lt;url&gt; -O file_name\n</code></pre> <p>Both are commonly used in scripts and pipelines.</p>","tags":["devops"]},{"location":"devops/linux/linux-commands/#installing-software-how-linux-decides-dependencies","title":"Installing software (how Linux decides dependencies)","text":"","tags":["devops"]},{"location":"devops/linux/linux-commands/#rpm-low-level","title":"rpm (low-level)","text":"<pre><code>rpm -i ansible.rpm\n</code></pre> <ul> <li>Installs one package</li> <li>Does not resolve dependencies</li> </ul> <p>Use when:</p> <ul> <li>Offline installs</li> <li>Controlled environments</li> </ul>","tags":["devops"]},{"location":"devops/linux/linux-commands/#yum-high-level","title":"yum (high-level)","text":"<pre><code>yum install ansible\n</code></pre> <ul> <li>Resolves dependencies</li> <li>Uses repositories</li> </ul> <p>Repositories live in:</p> <pre><code>/etc/yum.repos.d/\n</code></pre> <p>Yum:</p> <ul> <li>Compares available versions</li> <li>Selects compatible packages</li> <li>Avoids conflicts</li> </ul> <p>Other systems use:</p> <ul> <li><code>apt</code></li> <li><code>dnf</code></li> <li><code>zypper</code></li> </ul> <p>The idea is the same everywhere.</p>","tags":["devops"]},{"location":"devops/linux/linux-commands/#services-and-systemd-process-thinking","title":"Services and systemd (process thinking)","text":"<p>Modern Linux uses systemd to manage services.</p> <p>Check service state:</p> <pre><code>systemctl status my_app\n</code></pre> <p>Start service:</p> <pre><code>systemctl start my_app\n</code></pre> <p>Older <code>service</code> command still exists but wraps <code>systemctl</code>.</p>","tags":["devops"]},{"location":"devops/linux/linux-commands/#creating-a-simple-service-reasoning-example","title":"Creating a simple service (reasoning example)","text":"<p>You have:</p> <pre><code>/opt/my_app/my_app.py\n</code></pre> <p>Create:</p> <pre><code>/etc/systemd/system/my_app.service\n</code></pre> <pre><code>[Unit]\nDescription=My Sample App\n\n[Service]\nExecStart=/usr/bin/python3 /opt/my_app/my_app.py\nRestart=always\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>Reload systemd:</p> <pre><code>systemctl daemon-reload\n</code></pre> <p>Enable and start:</p> <pre><code>systemctl enable my_app\nsystemctl start my_app\n</code></pre> <p>Thinking model:</p> <ul> <li><code>[Unit]</code> explains what</li> <li><code>[Service]</code> explains how</li> <li><code>[Install]</code> explains when</li> </ul> <p>Linux is powerful because it exposes its internals in a consistent, scriptable way. Once you understand how Linux thinks about identity, files, processes, and services, DevOps and cloud concepts stop feeling magical and start feeling logical.</p>","tags":["devops"]},{"location":"devops/linux/linux-filesystem/","title":"Linux Filesystem Layout","text":"","tags":["devops"]},{"location":"devops/linux/linux-filesystem/#how-john-learns-why-everything-lives-where-it-does","title":"How John Learns Why Everything Lives Where It Does","text":"<p>John is now comfortable logging into Linux. He can run commands, edit files, and start services. But one question keeps coming up:</p> <p>\u201cWhere should things actually go?\u201d</p> <p>Linux does not place files randomly. The filesystem layout exists to solve real operational problems.</p>","tags":["devops"]},{"location":"devops/linux/linux-filesystem/#john-explores-the-root-of-the-filesystem","title":"John explores the root of the filesystem","text":"<p>John starts at the top:</p> <pre><code>ls /\n</code></pre> <p>He sees directories like <code>/bin</code>, <code>/etc</code>, <code>/var</code>, <code>/opt</code>, <code>/home</code>, <code>/tmp</code>.</p> <p>At first, this looks arbitrary. It is not.</p> <p>Linux follows a standard layout so that:</p> <ul> <li>admins know where to look</li> <li>tools know where to read from</li> <li>automation behaves consistently across systems</li> </ul>","tags":["devops"]},{"location":"devops/linux/linux-filesystem/#home-where-humans-live","title":"<code>/home</code>: where humans live","text":"<p>John checks:</p> <pre><code>ls /home\n</code></pre> <p>He sees his own directory:</p> <pre><code>/home/john\n</code></pre> <p>This directory exists because:</p> <ul> <li>each user needs a private workspace</li> <li>permissions isolate users from each other</li> <li>backups can target user data easily</li> </ul> <p>John creates a file:</p> <pre><code>touch /home/john/test.txt\n</code></pre> <p>Linux allows this because John owns his home directory.</p>","tags":["devops"]},{"location":"devops/linux/linux-filesystem/#root-why-john-was-denied-earlier","title":"<code>/root</code>: why John was denied earlier","text":"<p>Earlier, John tried:</p> <pre><code>ls /root\n</code></pre> <p>and got \u201cpermission denied\u201d.</p> <p>Now it makes sense.</p> <p><code>/root</code> is:</p> <ul> <li>the home directory of the <code>root</code> user</li> <li>intentionally separate from <code>/home</code></li> <li>protected from regular users</li> </ul> <p>Root is a user, not magic. It just has a different home.</p>","tags":["devops"]},{"location":"devops/linux/linux-filesystem/#bin-and-sbin-basic-commands-live-here","title":"<code>/bin</code> and <code>/sbin</code>: basic commands live here","text":"<p>John wonders where commands like <code>ls</code> actually come from.</p> <p>He checks:</p> <pre><code>which ls\n</code></pre> <p>Output:</p> <pre><code>/bin/ls\n</code></pre> <p>This tells him:</p> <ul> <li><code>/bin</code> contains essential user commands</li> <li>these commands must be available even in recovery mode</li> </ul> <p>Similarly:</p> <pre><code>which ip\n</code></pre> <p>might point to:</p> <pre><code>/sbin/ip\n</code></pre> <p><code>/sbin</code> contains system-level commands meant for administrators.</p>","tags":["devops"]},{"location":"devops/linux/linux-filesystem/#etc-configuration-lives-here-and-only-here","title":"<code>/etc</code>: configuration lives here (and only here)","text":"<p>John edits a service file earlier in <code>/etc/systemd/system</code>. Now he understands why.</p> <p><code>/etc</code> exists for configuration only.</p> <p>John lists it:</p> <pre><code>ls /etc\n</code></pre> <p>He sees:</p> <ul> <li>service configs</li> <li>user configs</li> <li>network configs</li> </ul> <p>Important rule:</p> <p>Executables do not live in <code>/etc</code>. Data does not live in <code>/etc</code>. Only configuration.</p> <p>This separation allows:</p> <ul> <li>safe upgrades</li> <li>easy backups</li> <li>predictable automation</li> </ul>","tags":["devops"]},{"location":"devops/linux/linux-filesystem/#var-data-that-changes-while-the-system-runs","title":"<code>/var</code>: data that changes while the system runs","text":"<p>John notices logs are not in <code>/etc</code>.</p> <p>He checks:</p> <pre><code>ls /var\n</code></pre> <p>He sees directories like:</p> <ul> <li><code>/var/log</code></li> <li><code>/var/lib</code></li> <li><code>/var/tmp</code></li> </ul> <p>He opens logs:</p> <pre><code>ls /var/log\n</code></pre> <p>This explains why:</p> <ul> <li>logs grow over time</li> <li>disk-full issues often come from <code>/var</code></li> <li><code>/var</code> is monitored closely in production</li> </ul> <p>Applications write changing data here, not in <code>/etc</code>.</p>","tags":["devops"]},{"location":"devops/linux/linux-filesystem/#tmp-temporary-means-temporary","title":"<code>/tmp</code>: temporary means temporary","text":"<p>John creates a file:</p> <pre><code>touch /tmp/test.tmp\n</code></pre> <p>It works. But after a reboot, the file is gone.</p> <p>This teaches an important rule:</p> <p><code>/tmp</code> is for short-lived files only.</p> <p>System cleanups and reboots can wipe it at any time.</p>","tags":["devops"]},{"location":"devops/linux/linux-filesystem/#opt-where-applications-belong","title":"<code>/opt</code>: where applications belong","text":"<p>John earlier placed his app in <code>/opt/my_app</code>.</p> <p>Now he understands why.</p> <p><code>/opt</code> exists for:</p> <ul> <li>optional software</li> <li>third-party applications</li> <li>custom deployments</li> </ul> <p>This keeps applications separate from:</p> <ul> <li>OS binaries (<code>/bin</code>)</li> <li>configs (<code>/etc</code>)</li> <li>logs (<code>/var/log</code>)</li> </ul> <p>In production systems, this separation prevents accidental overwrites during OS upgrades.</p>","tags":["devops"]},{"location":"devops/linux/linux-filesystem/#usr-os-installed-software","title":"<code>/usr</code>: OS-installed software","text":"<p>John installs a package:</p> <pre><code>yum install python3\n</code></pre> <p>He checks:</p> <pre><code>which python3\n</code></pre> <p>Output:</p> <pre><code>/usr/bin/python3\n</code></pre> <p>This tells him:</p> <ul> <li><code>/usr</code> holds OS-managed software</li> <li>package managers control this space</li> <li>admins should not manually edit files here</li> </ul>","tags":["devops"]},{"location":"devops/linux/linux-filesystem/#why-this-layout-matters-in-real-systems","title":"Why this layout matters in real systems","text":"<p>Later, John joins a production incident call.</p> <p>The service is down.</p> <p>The team asks:</p> <ul> <li>\u201cCheck logs\u201d \u2192 <code>/var/log</code></li> <li>\u201cCheck config\u201d \u2192 <code>/etc</code></li> <li>\u201cCheck app binaries\u201d \u2192 <code>/opt</code></li> <li>\u201cCheck user scripts\u201d \u2192 <code>/home</code></li> </ul> <p>No guessing. Everyone knows where to look.</p> <p>That is the real value of the filesystem layout.</p>","tags":["devops"]},{"location":"devops/linux/linux-filesystem/#johns-final-mental-model","title":"John\u2019s final mental model","text":"<p>John now thinks about Linux like this:</p> <ul> <li><code>/home</code> \u2192 humans</li> <li><code>/root</code> \u2192 superuser</li> <li><code>/bin</code>, <code>/sbin</code> \u2192 core commands</li> <li><code>/etc</code> \u2192 configuration</li> <li><code>/var</code> \u2192 changing data</li> <li><code>/opt</code> \u2192 applications</li> <li><code>/tmp</code> \u2192 temporary files</li> <li><code>/usr</code> \u2192 OS-managed software</li> </ul> <p>Linux did not choose this structure randomly. It chose it so humans and automation could work together without confusion.</p>","tags":["devops"]},{"location":"devops/linux/linux-filesystem/#final-takeaway","title":"Final takeaway","text":"<p>Understanding the Linux filesystem is not about memorizing directories. It is about knowing where responsibility lives.</p> <p>Once John understands this, production systems stop feeling chaotic and start feeling organized.</p>","tags":["devops"]},{"location":"devops/linux/linux-process-signal-ports/","title":"Processes, Signals, and Ports","text":"","tags":["devops"]},{"location":"devops/linux/linux-process-signal-ports/#how-linux-actually-runs-things","title":"How Linux Actually Runs Things","text":"<p>If you want to understand Linux beyond commands, you must understand three ideas: processes, signals, and ports. These are not advanced topics. They are the core mechanics of how Linux runs anything at all.</p> <p>Once these are clear, many things that look confusing\u2014hung services, failed restarts, port conflicts, Kubernetes behaviour\u2014start making sense.</p>","tags":["devops"]},{"location":"devops/linux/linux-process-signal-ports/#what-linux-means-by-a-process","title":"What Linux means by a \u201cprocess\u201d","text":"<p>In Linux, a process is simply a running program.</p> <p>When you type a command like:</p> <pre><code>ls\n</code></pre> <p>Linux does not \u201crun ls\u201d in a magical way. The kernel performs a very specific sequence of actions. It creates a new process, assigns it a unique number called a PID, runs the program in memory, and destroys the process once the work is done.</p> <p>This same model applies everywhere. A shell command, a Python script, a database, a web server, or a container\u2014all of them are processes from Linux\u2019s point of view. Linux does not care what the program does; it only manages how it runs.</p>","tags":["devops"]},{"location":"devops/linux/linux-process-signal-ports/#observing-processes-instead-of-guessing","title":"Observing processes instead of guessing","text":"<p>To understand what is happening on a system, you do not guess. You observe processes.</p> <p>A command like:</p> <pre><code>ps -ef\n</code></pre> <p>shows you what is running at that moment. It tells you which user started a process, which process started it, and what command was used. This matters because Linux always knows who started what, and responsibility is never ambiguous.</p> <p>For live systems, administrators usually use:</p> <pre><code>top\n</code></pre> <p>This answers practical questions like why a server feels slow or which process is consuming memory. Performance troubleshooting in Linux almost always begins by looking at processes, not logs.</p>","tags":["devops"]},{"location":"devops/linux/linux-process-signal-ports/#parent-and-child-processes-why-structure-matters","title":"Parent and child processes (why structure matters)","text":"<p>Processes in Linux are not random. They form a tree.</p> <p>When one process starts another, the first becomes the parent and the second becomes the child. For example, a shell may start a Python process, which in turn starts another helper process. Linux keeps track of this entire relationship.</p> <p>This structure explains many behaviours. If a parent process dies, child processes may also stop, or they may be adopted by another process. This is why long-running applications should not be started casually in the background.</p>","tags":["devops"]},{"location":"devops/linux/linux-process-signal-ports/#pid-1-and-why-systemd-exists","title":"PID 1 and why systemd exists","text":"<p>Every Linux system has a special process with PID 1. This is the first process started by the kernel, and on modern systems it is <code>systemd</code>.</p> <p>The role of PID 1 is not to run applications directly. Its role is to manage other processes. It starts services, restarts them if they crash, handles shutdown, and cleans up orphaned processes. Without PID 1 doing this work, Linux would slowly become unstable.</p> <p>This is why systemd is not optional on modern servers. It exists to keep the process tree healthy.</p>","tags":["devops"]},{"location":"devops/linux/linux-process-signal-ports/#foreground-and-background-processes","title":"Foreground and background processes","text":"<p>When you run a command normally, it runs in the foreground. Your terminal stays attached to the process, and you cannot do anything else until it exits.</p> <p>When you append <code>&amp;</code>, the process runs in the background, detached from your terminal. However, this does not mean the process is managed. It simply means your shell is no longer waiting for it.</p> <p>This distinction matters because production services should never depend on terminals. They should be managed by systemd, not by background execution.</p>","tags":["devops"]},{"location":"devops/linux/linux-process-signal-ports/#signals-how-linux-talks-to-processes","title":"Signals: how Linux talks to processes","text":"<p>Linux does not control processes by force. It communicates with them using signals.</p> <p>A signal is a message sent by the kernel to a process. The message tells the process what is happening or what is expected of it. For example, when you press Ctrl+C, Linux sends a signal asking the process to stop.</p> <p>When you run:</p> <pre><code>kill &lt;PID&gt;\n</code></pre> <p>Linux sends a polite signal requesting the process to terminate. Well-written applications respond by cleaning up and exiting gracefully. If a process ignores this request, a stronger signal can be sent that forces it to stop immediately.</p> <p>The important idea here is not memorizing signal numbers. The important idea is understanding that Linux asks first, and forces only as a last resort.</p>","tags":["devops"]},{"location":"devops/linux/linux-process-signal-ports/#why-signals-matter-in-real-systems","title":"Why signals matter in real systems","text":"<p>In production systems, signals separate good applications from bad ones.</p> <p>A good application listens for termination signals, closes files, releases ports, and exits cleanly. A poorly written application ignores signals, leaves resources behind, and causes unpredictable behaviour. Many \u201cmysterious\u201d production issues are simply applications mishandling signals.</p> <p>This is also why platforms like Kubernetes rely heavily on signals during pod shutdown.</p>","tags":["devops"]},{"location":"devops/linux/linux-process-signal-ports/#ports-how-processes-expose-services","title":"Ports: how processes expose services","text":"<p>A port is not a process. A port is simply a number managed by the kernel.</p> <p>When a server application starts, it asks the kernel to associate itself with a port. If the kernel grants the request, traffic arriving on that port is forwarded to the process. If another process already owns the port, the request fails.</p> <p>This explains why errors like \u201caddress already in use\u201d occur. Linux is preventing two processes from listening on the same port at the same time.</p>","tags":["devops"]},{"location":"devops/linux/linux-process-signal-ports/#understanding-port-ownership","title":"Understanding port ownership","text":"<p>To troubleshoot network issues, you must connect ports back to processes.</p> <p>A command like:</p> <pre><code>ss -lntp\n</code></pre> <p>shows which processes are listening on which ports. This allows you to answer concrete questions: which application is using port 8080, why a service failed to start, or whether an old process is still running.</p> <p>Ports never exist on their own. They always belong to processes.</p>","tags":["devops"]},{"location":"devops/linux/linux-process-signal-ports/#how-systemd-signals-and-ports-work-together","title":"How systemd, signals, and ports work together","text":"<p>When you stop a service using systemd, Linux follows a controlled sequence. Systemd sends a termination signal, waits for the process to exit cleanly, and only forces termination if the process refuses to stop. When the process exits, its ports are automatically released.</p> <p>This predictable behaviour is the reason modern Linux systems remain stable even under frequent restarts and deployments.</p>","tags":["devops"]},{"location":"devops/linux/linux-process-signal-ports/#final-way-to-think-about-it","title":"Final way to think about it","text":"<p>Linux runs programs as processes. It communicates with them using signals. Processes expose functionality to the network using ports.</p> <p>Nothing more, nothing less.</p> <p>If you understand this model, Linux stops feeling opaque and starts feeling logical.</p>","tags":["devops"]},{"location":"devops/linux/linux-process-signal-ports/#final-takeaway","title":"Final takeaway","text":"<p>Linux does not hide how things run. It exposes processes, signals, and ports so that you can reason about system behaviour instead of guessing. This transparency is the reason Linux scales so well in servers, containers, and cloud platforms.</p> <p>This version should now feel connected, readable, and intentional, not like copied documentation.</p>","tags":["devops"]},{"location":"devops/linux/user-access-in-linux-servers/","title":"How Linux Server Access Is Set Up in Enterprises","text":"<p>When an enterprise sets up its first Linux server, access control usually starts in the simplest possible way. The server runs Red Hat Enterprise Linux, the <code>root</code> user exists, and an administrator logs in directly to perform all tasks. At this stage, nothing feels wrong because only one person is using the system.</p>","tags":["devops"]},{"location":"devops/linux/user-access-in-linux-servers/#john-joins-the-company","title":"John joins the company","text":"<p>John joins the company as an application developer. To work on his application, he needs access to the Linux server. John raises an access request using the company\u2019s access management tool, such as SailPoint, Saviynt, or an in-house system.</p> <p>The Linux administrator creates a local user account for John and sets a password.</p> <pre><code>useradd -m john\npasswd john\n</code></pre> <p>This updates the standard Linux account files: <code>/etc/passwd</code> stores the user entry, <code>/etc/shadow</code> stores the password hash, and <code>/etc/group</code> records group membership. John is given the server address, a username, and a temporary password. He can now log in using SSH.</p> <pre><code>ssh john@server\n</code></pre> <p>John can access his home directory, but he cannot read system directories such as <code>/root</code>. This is expected and correct.</p>","tags":["devops"]},{"location":"devops/linux/user-access-in-linux-servers/#the-first-mistake-giving-everyone-sudo","title":"The first mistake: giving everyone sudo","text":"<p>Very soon, John needs to start the application, run scripts, and check logs. The quickest solution seems to be adding John to sudo.</p> <pre><code>usermod -aG wheel john\n</code></pre> <p>Now John can become root using <code>sudo</code>. This works, but it introduces a serious problem. John is no longer just an application developer; he now has full control of the operating system. When a second developer joins, the same access is given again. At this point, multiple developers can act as root, and the server becomes fragile and unsafe.</p>","tags":["devops"]},{"location":"devops/linux/user-access-in-linux-servers/#introducing-an-application-service-account","title":"Introducing an application service account","text":"<p>The first real application is deployed, and a new question appears: who should own the application and run it? The answer is neither a human user nor root. Applications should run under their own service accounts.</p> <p>The administrator creates a dedicated application user.</p> <pre><code>useradd -r -m -d /opt/app -s /sbin/nologin appsvc\npasswd -l appsvc\n</code></pre> <p>This account exists only to run the application. No one logs in as this user. Application files and logs are owned by <code>appsvc</code>, which cleanly separates application activity from human activity.</p>","tags":["devops"]},{"location":"devops/linux/user-access-in-linux-servers/#giving-developers-the-right-access","title":"Giving developers the right access","text":"<p>Developers like John need to manage the application, but they do not need root access. This is solved by using groups and sudo rules instead of direct privileges.</p> <p>A group is created for application administrators, and developers are added to it.</p> <pre><code>groupadd app-admin\nusermod -aG app-admin john\n</code></pre> <p>A sudo rule is then defined.</p> <p>File: <code>/etc/sudoers.d/app-admin</code></p> <pre><code>%app-admin ALL=(appsvc) ALL\n</code></pre> <p>Now John can run application commands as the application user without becoming root.</p> <pre><code>sudo -u appsvc ./start.sh\n</code></pre> <p>The boundary is clear: developers manage the application, and the operating system remains protected.</p>","tags":["devops"]},{"location":"devops/linux/user-access-in-linux-servers/#production-servers-and-operations-access","title":"Production servers and operations access","text":"<p>When a production server is introduced, an operations team is responsible for system stability. These users need higher privileges than developers, but they still should not log in as root.</p> <p>An operations group is created, and sudo access is granted through that group.</p> <pre><code>groupadd linux-admin\nusermod -aG linux-admin ops1\n</code></pre> <p>File: <code>/etc/sudoers.d/linux-admin</code></p> <pre><code>%linux-admin ALL=(ALL) ALL\n</code></pre> <p>At the same time, direct root login is disabled in <code>/etc/ssh/sshd_config</code>. Root exists, but it is accessed only through sudo, ensuring every action is logged.</p>","tags":["devops"]},{"location":"devops/linux/user-access-in-linux-servers/#scaling-the-model","title":"Scaling the model","text":"<p>As the company grows, manually creating users on every server becomes unmanageable. At this point, the enterprise integrates Linux servers with a central directory such as LDAP or Active Directory and connects it to an IGA tool.</p> <p>Linux no longer manages users directly. It trusts directory users and groups, configured through files like <code>/etc/sssd/sssd.conf</code> and <code>/etc/nsswitch.conf</code>. Access is now granted by adding a user to the correct group in the directory, and the change applies consistently across all servers.</p>","tags":["devops"]},{"location":"devops/linux/user-access-in-linux-servers/#final-state","title":"Final state","text":"<p>In the final, stable setup, people log in using personal accounts, applications run as service users, and root access is available only through sudo. Groups define what users can do, and all access is auditable through logs such as <code>/var/log/secure</code> and <code>journalctl</code>.</p> <p>This structure exists because enterprises had to move from \u201cjust give root\u201d to a model that scales safely, supports audits, and clearly separates human access from application execution.</p>","tags":["devops"]},{"location":"devops/networking/dns/","title":"DNS Basics","text":""},{"location":"devops/networking/dns/#how-names-become-ip-addresses","title":"How names become IP addresses","text":"<p>John now has machines talking to each other across networks. Networking works.</p> <p>But there is still a problem.</p> <p>Communicating using IP addresses is painful. IPs are hard to remember and do not explain what a machine actually does.</p> <p>This is where DNS comes in.</p>"},{"location":"devops/networking/dns/#the-problem-why-dns-exists","title":"The problem (why DNS exists)","text":"<p>John has a database server with this IP:</p> <pre><code>\n192.168.1.1\n\n</code></pre> <p>He can reach it, but:</p> <ul> <li>The IP does not say what the machine is</li> <li>Humans do not remember IPs easily</li> <li>IPs can change</li> </ul> <p>John wants to say:</p> <p>\u201cConnect to the database server\u201d</p> <p>not:</p> <p>\u201cConnect to 192.168.1.1\u201d</p>"},{"location":"devops/networking/dns/#name-resolution-the-basic-idea","title":"Name resolution (the basic idea)","text":"<p>Name resolution means:</p> <p>Converting a name into an IP address</p> <p>Example:</p> <pre><code>\ndb  \u2192  192.168.1.1\n\n````\n\nLinux always performs name resolution before connecting to a host.\n\n---\n\n## `/etc/hosts` (local name resolution)\n\nJohn starts with the simplest method.\n\nHe edits:\n\n```bash\n/etc/hosts\n````\n\nAdds:\n\n```text\n192.168.1.1 db\n</code></pre> <p>Now he runs:</p> <pre><code>ping db\n</code></pre> <p>It works.</p> <p>Linux replaced <code>db</code> with <code>192.168.1.1</code>.</p>"},{"location":"devops/networking/dns/#why-etchosts-does-not-scale","title":"Why <code>/etc/hosts</code> does not scale","text":"<p><code>/etc/hosts</code> works, but it has serious limitations.</p> <ul> <li>It is local to one system</li> <li>Another system may use a different name for the same IP</li> <li>IP changes require updating every machine</li> <li>Wrong entries can silently break communication</li> </ul> <p>This approach works only for:</p> <ul> <li>Very small setups</li> <li>Temporary test systems</li> </ul> <p>For large environments, this does not scale.</p>"},{"location":"devops/networking/dns/#dns-server-central-source-of-truth","title":"DNS server (central source of truth)","text":"<p>Instead of every machine maintaining its own mapping, John introduces a DNS server.</p> <p>Now:</p> <ul> <li>One system stores name \u2192 IP mappings</li> <li>All hosts query it</li> <li>Changes are made in one place</li> </ul> <p>This becomes the source of truth.</p>"},{"location":"devops/networking/dns/#etcresolvconf-where-linux-looks-for-dns","title":"<code>/etc/resolv.conf</code> (where Linux looks for DNS)","text":"<p>Each Linux host must know which DNS server to ask.</p> <p>John checks:</p> <pre><code>cat /etc/resolv.conf\n</code></pre> <p>He adds:</p> <pre><code>nameserver 192.168.1.53\n</code></pre> <p>Now:</p> <ul> <li>Every hostname lookup goes to the DNS server</li> <li><code>/etc/hosts</code> is no longer the only source</li> </ul>"},{"location":"devops/networking/dns/#local-override-still-exists","title":"Local override still exists","text":"<p>Even with DNS configured, <code>/etc/hosts</code> still works.</p> <p>John can add temporary entries:</p> <pre><code>192.168.1.100 temp-db\n</code></pre> <p>No DNS change required.</p> <p>This is useful for:</p> <ul> <li>Testing</li> <li>Temporary servers</li> <li>Debugging</li> </ul>"},{"location":"devops/networking/dns/#resolution-order-who-is-asked-first","title":"Resolution order (who is asked first)","text":"<p>Linux follows an order when resolving names.</p> <p>That order is defined in:</p> <pre><code>/etc/nsswitch.conf\n</code></pre> <p>John checks the <code>hosts</code> line:</p> <pre><code>hosts: files dns\n</code></pre> <p>Meaning:</p> <ol> <li>Check <code>/etc/hosts</code></li> <li>If not found, query DNS</li> </ol> <p>This order can be changed, but the default is sensible.</p>"},{"location":"devops/networking/dns/#dns-for-the-internet","title":"DNS for the internet","text":"<p>Internal DNS servers cannot resolve internet domains by themselves.</p> <p>To fix this, John configures DNS forwarding.</p> <p>The DNS server forwards unknown requests to public DNS servers like:</p> <pre><code>8.8.8.8\n8.8.4.4\n</code></pre> <p>Now:</p> <ul> <li>Internal names resolve internally</li> <li>External names resolve via the internet</li> </ul>"},{"location":"devops/networking/dns/#domain-names-how-names-are-structured","title":"Domain names (how names are structured)","text":"<p>DNS names are hierarchical.</p> <p>Example:</p> <pre><code>apps.google.com\n</code></pre> <p>Breakdown:</p> <ul> <li><code>.com</code> \u2192 top-level domain</li> <li><code>google</code> \u2192 domain</li> <li><code>apps</code> \u2192 subdomain</li> </ul> <p>Other top-level domains:</p> <ul> <li><code>.com</code> \u2192 commercial</li> <li><code>.net</code> \u2192 network</li> <li><code>.org</code> \u2192 organization</li> <li><code>.edu</code> \u2192 education</li> <li><code>.io</code> \u2192 Indian Ocean territory (popular in tech)</li> </ul>"},{"location":"devops/networking/dns/#how-dns-resolution-actually-happens","title":"How DNS resolution actually happens","text":"<p>When John accesses:</p> <pre><code>apps.google.com\n</code></pre> <p>Resolution flow:</p> <ol> <li>Organization DNS checks cache</li> <li>If not found, asks root DNS</li> <li>Root DNS points to <code>.com</code> DNS</li> <li><code>.com</code> DNS points to Google DNS</li> <li>Google DNS returns IP for <code>apps.google.com</code></li> </ol> <p>The result is cached so the next request is faster.</p>"},{"location":"devops/networking/dns/#search-domains-short-names-inside-organizations","title":"Search domains (short names inside organizations)","text":"<p>Inside John\u2019s company, the database server is named:</p> <pre><code>db.mycompany.com\n</code></pre> <p>John wants to type:</p> <pre><code>ping db\n</code></pre> <p>Linux supports this using search domains.</p> <p>In <code>/etc/resolv.conf</code>:</p> <pre><code>search mycompany.com\n</code></pre> <p>Now:</p> <ul> <li><code>db</code> automatically expands to <code>db.mycompany.com</code></li> <li>Multiple search domains can be configured</li> </ul>"},{"location":"devops/networking/dns/#dns-record-types-what-dns-stores","title":"DNS record types (what DNS stores)","text":"<p>DNS does not store just one type of record.</p>"},{"location":"devops/networking/dns/#a-record","title":"A record","text":"<p>Maps hostname to IPv4 address.</p> <pre><code>db.mycompany.com \u2192 192.168.1.1\n</code></pre>"},{"location":"devops/networking/dns/#aaaa-record","title":"AAAA record","text":"<p>Maps hostname to IPv6 address.</p> <pre><code>db.mycompany.com \u2192 fe80::1\n</code></pre>"},{"location":"devops/networking/dns/#cname-record","title":"CNAME record","text":"<p>Creates an alias.</p> <pre><code>web.mycompany.com \u2192 app.mycompany.com\n</code></pre> <p>Used when:</p> <ul> <li>One service has multiple names</li> <li>Backends change, names do not</li> </ul>"},{"location":"devops/networking/dns/#testing-dns-resolution","title":"Testing DNS resolution","text":"<p>John tests DNS directly.</p>"},{"location":"devops/networking/dns/#nslookup","title":"<code>nslookup</code>","text":"<pre><code>nslookup db.mycompany.com\n</code></pre> <p>This queries DNS servers directly. It ignores <code>/etc/hosts</code>.</p>"},{"location":"devops/networking/dns/#dig","title":"<code>dig</code>","text":"<pre><code>dig db.mycompany.com\n</code></pre> <p>This provides:</p> <ul> <li>Full DNS response</li> <li>Useful debugging details</li> </ul> <p>Preferred tool for troubleshooting.</p>"},{"location":"devops/networking/dns/#what-john-understands-now","title":"What John understands now","text":"<ul> <li>IPs are hard to use directly</li> <li>Name resolution converts names to IPs</li> <li><code>/etc/hosts</code> is local and limited</li> <li>DNS is centralized and scalable</li> <li>Resolution order matters</li> <li>DNS caching improves performance</li> <li>Search domains simplify internal usage</li> </ul> <p>DNS works because everyone agrees on where truth lives.</p>"},{"location":"devops/networking/dns/#quick-cheat-sheet","title":"Quick cheat sheet","text":"<pre><code># Local name mapping\n/etc/hosts\n\n# DNS server config\n/etc/resolv.conf\n\n# Resolution order\n/etc/nsswitch.conf\n\n# Test DNS\nnslookup hostname\ndig hostname\n</code></pre>"},{"location":"devops/networking/networking-basics/","title":"Networking Basics","text":""},{"location":"devops/networking/networking-basics/#switching-routing-and-gateways-one-idea-at-a-time","title":"Switching, routing, and gateways (one idea at a time)","text":"<p>John now has multiple Linux systems. They all work individually, but real systems are useless unless they can talk to each other.</p> <p>This page explains how communication works, step by step, without skipping logic.</p>"},{"location":"devops/networking/networking-basics/#switch-how-two-systems-meet","title":"Switch (how two systems meet)","text":"<p>Two systems talk to each other by being part of the same network.</p> <p>A switch creates that network.</p> <p>John connects: - System A - System B</p> <p>to the same switch.</p> <p>At this point, the switch only knows how to pass packets, not who is who.</p>"},{"location":"devops/networking/networking-basics/#network-interface-how-a-system-connects","title":"Network interface (how a system connects)","text":"<p>To connect to a switch, each system needs a network interface.</p> <p>John checks available interfaces:</p> <pre><code>ip link\n````\n\nHe sees:\n\n```text\neth0\n</code></pre> <p>This interface represents the physical or virtual connection to the switch.</p> <p>No interface means no network connectivity.</p>"},{"location":"devops/networking/networking-basics/#ip-address-identity-on-the-network","title":"IP address (identity on the network)","text":"<p>A switch alone is not enough. Each system needs an IP address.</p> <p>John chooses a network:</p> <pre><code>192.168.1.0/24\n</code></pre> <p>He assigns IPs.</p>"},{"location":"devops/networking/networking-basics/#system-a","title":"System A","text":"<pre><code>ip addr add 192.168.1.10/24 dev eth0\n</code></pre>"},{"location":"devops/networking/networking-basics/#system-b","title":"System B","text":"<pre><code>ip addr add 192.168.1.11/24 dev eth0\n</code></pre> <p>Now:</p> <ul> <li>Both systems are on the same network</li> <li>Each has a unique identity</li> <li>They can talk to each other</li> </ul>"},{"location":"devops/networking/networking-basics/#route-how-linux-decides-where-to-send-packets","title":"Route (how Linux decides where to send packets)","text":"<p>Linux does not guess. It uses a routing table.</p> <p>John checks it:</p> <pre><code>route\n</code></pre> <p>This shows the kernel IP routing table.</p> <p>Every outgoing packet is matched against this table to decide:</p> <ul> <li>Where to send it</li> <li>Through which interface</li> </ul> <p>If no route matches, the packet is dropped.</p>"},{"location":"devops/networking/networking-basics/#router-how-networks-talk-to-networks","title":"Router (how networks talk to networks)","text":"<p>Now John has two networks:</p> <pre><code>192.168.1.0/24\n192.168.2.0/24\n</code></pre> <p>A router connects networks.</p> <p>A router is simply a system that:</p> <ul> <li>Has an IP in each network</li> <li>Can forward packets between them</li> </ul> <p>Example router IPs:</p> <ul> <li>192.168.1.11</li> <li>192.168.2.11</li> </ul>"},{"location":"devops/networking/networking-basics/#gateway-how-systems-find-the-router","title":"Gateway (how systems find the router)","text":"<p>The router is just another device. How does a system know it should use it?</p> <p>That device becomes the gateway.</p> <p>A gateway is:</p> <ul> <li>The next hop for another network</li> <li>The \u201cdoor\u201d out of the current network</li> </ul> <p>John adds a route:</p> <pre><code>ip route add 192.168.2.0/24 via 192.168.1.11\n</code></pre> <p>Meaning:</p> <p>\u201cTo reach 192.168.2.0, send packets to 192.168.1.11\u201d</p> <p>This must be added on every system that needs access to the other network.</p>"},{"location":"devops/networking/networking-basics/#default-gateway-door-to-everything-else","title":"Default gateway (door to everything else)","text":"<p>The internet has too many networks to define routes for each.</p> <p>So systems use a default gateway.</p> <p>Default means:</p> <ul> <li>\u201cIf no route matches, send traffic here\u201d</li> </ul> <p>John adds:</p> <pre><code>ip route add default via 192.168.1.11\n</code></pre> <p>Now:</p> <ul> <li>Known networks use specific routes</li> <li>All other traffic goes to the gateway</li> </ul> <p>This is how systems reach the internet.</p>"},{"location":"devops/networking/networking-basics/#linux-as-a-router-packet-forwarding","title":"Linux as a router (packet forwarding)","text":"<p>John now wants his Linux system to act as a router.</p> <p>By default, Linux does not forward packets between interfaces.</p> <p>He checks:</p> <pre><code>cat /proc/sys/net/ipv4/ip_forward\n</code></pre> <p>Output:</p> <pre><code>0\n</code></pre> <p>This means forwarding is disabled.</p>"},{"location":"devops/networking/networking-basics/#enabling-forwarding-making-linux-a-router","title":"Enabling forwarding (making Linux a router)","text":"<p>John enables forwarding temporarily:</p> <pre><code>echo 1 &gt; /proc/sys/net/ipv4/ip_forward\n</code></pre> <p>To make it permanent, he updates:</p> <pre><code>/etc/sysctl.conf\n</code></pre> <p>Adds:</p> <pre><code>net.ipv4.ip_forward = 1\n</code></pre> <p>Applies it:</p> <pre><code>sysctl -p\n</code></pre> <p>Now Linux forwards packets between networks.</p>"},{"location":"devops/networking/networking-basics/#what-john-understands-now","title":"What John understands now","text":"<ul> <li>Switch connects systems in the same network</li> <li>Interfaces connect systems to the switch</li> <li>IP addresses identify systems</li> <li>Routes decide where packets go</li> <li>Gateways point to routers</li> <li>Default gateway handles unknown networks</li> <li>Linux can be a router, but only if forwarding is enabled</li> </ul> <p>Networking works because everything is explicit.</p>"},{"location":"devops/networking/networking-basics/#quick-cheat-sheet","title":"Quick cheat sheet","text":"<pre><code># Show interfaces\nip link\n\n# Assign IP\nip addr add &lt;ip&gt;/&lt;mask&gt; dev &lt;iface&gt;\n\n# Show routes\nroute\n\n# Add route\nip route add &lt;network&gt; via &lt;gateway&gt;\n\n# Add default gateway\nip route add default via &lt;gateway&gt;\n\n# Enable forwarding\necho 1 &gt; /proc/sys/net/ipv4/ip_forward\n</code></pre>"}]}